1. 功能行为清单还没有（最关键的阻塞项）

文档里明确写了"功能行为清单由人工编制，不由 agent 生成"，但目前项目里还没有这份清单。Big Bang 最大的风险就是"重写了 80% 然后发现剩下 20% 的边界情况要花 80% 的时间"。建议在动手前把这份清单做出来，至少覆盖：

画笔（freehand + paintbrush）的所有行为，包括压感、auto-split、LOD 裁剪
选择的所有模式（点选、框选、涂鸦选、Shift 多选、深度选择）
橡皮擦的行为（擦除预览、scribble 模式）
文本节点的完整交互（创建、编辑、富文本、IME）
图片节点的交互（拖入、标记、变换手柄）
快捷键映射表（当前所有绑定）
右键菜单的所有操作项
撤销/重做覆盖的操作范围
视口操作（pan、zoom、minimap 联动、scroll zoom）
图层系统行为（创建、切换、可见性、锁定）
没有这份清单，重构过程中你和 agent 都没有验收标准，很容易漏功能。

2. 现有测试的价值评估

测试里的断言逻辑描述了旧系统的预期行为——这本身就是功能行为清单的一部分。Big Bang 会让所有测试因为 import 路径和 API 变化而编译失败，但建议在删除前做一件事：把现有测试中的业务断言提取出来，作为功能行为清单的补充验证点。比如 layerManager.property.test.ts 里的 property-based test 描述了图层操作的不变量，这些不变量在新架构里应该同样成立。

3. 几个架构细节需要提前想清楚

ShapeRecord 的具体字段设计。文档给了 IShapeUtil 接口但没定义 ShapeRecord 的完整类型。笔触（points 数组 + 压感数据）、画刷（合成模式 + 透明度）、文本（Tiptap JSON）、图片（URL + 标记列表）的数据结构差异很大，需要决定是用 discriminated union 还是泛型 + 类型参数。这个决策影响 store slice 的设计。

Zustand store 里 Map<string, ShapeRecord> 的不可变更新策略。每次 putShape 都 new Map(state.shapes) 在几千个笔触时会有性能问题。需要提前决定是用 Immer middleware 还是自己做 structural sharing，或者笔触数据用另一种数据结构（比如按 layer 分桶）。

CameraController 用 @preact/signals 管理 viewport，但 DOM 通道的节点定位需要 CSS transform。这意味着每次 pan/zoom 时要更新所有 DOM 节点的 transform——当前 ReactFlow 帮你做了这件事。去掉 ReactFlow 后，你需要自己实现一个高效的 DOM 节点批量定位机制（一个 container div 上做 transform，而不是每个节点单独算）。

撤销/重做。文档提到用 undoMiddleware 替代 CommandManager，但没展开。Zustand 的 undo middleware（比如 zundo）是基于 state snapshot 的，而当前的 CommandManager 是基于 command 对象的。两种方案的内存开销和粒度控制差异很大，尤其是画笔操作（一笔可能有几百个点），需要提前确定方案。

4. 迁移顺序的一个风险点

文档的执行顺序是 Store → Infra → Editor → View → 工具 → 渲染 → 辅助功能。但在阶段 4（视图层骨架）完成之前，你没有任何可视化的验证手段。建议把阶段 4 的优先级提前，至少让 CanvasShell + 一个最简单的 DOM 节点能渲染出来，这样后续每迁移一个功能域都能立刻看到效果，而不是盲写到阶段 5 才能验证。

实际上可以考虑：Store 骨架 → View 骨架（最小可渲染）→ Editor 骨架 → 然后按功能域逐个填充。

5. 旧代码的保留策略

Big Bang 不等于一开始就删旧代码。建议在新目录结构（src/core/store/、src/core/editor/、src/view/）里从零开始写，旧代码（
MatelinkCanvas.tsx
、
layerManager.ts
、contexts/ 等）原地不动。两套代码并存期间，旧系统仍然可以跑，方便你随时对照行为。等新系统的功能行为清单 100% 通过后，再一次性删除旧代码。这不是绞杀者模式——你不需要适配器，只是保留旧代码作为参考。

6. ESLint 规则的时机

文档第七部分的 ESLint 规则（import/no-restricted-paths、max-lines 等）应该在阶段 1 骨架搭建时就配好并设为 error，而不是先 warn 再逐步升级。Big Bang 的优势就是新代码从第一天就遵守规则，没有历史包袱。对旧目录可以用 ESLint overrides 豁免。

总结：最大的阻塞项是功能行为清单，没有它 Big Bang 就是盲飞。其次是 ShapeRecord 类型设计和 undo 策略这两个架构细节，它们会影响 store 骨架的实现。其他都是执行层面的优化，可以边做边调。

